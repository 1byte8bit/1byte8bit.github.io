[{"title":"Git笔记及理解(不断补充)","url":"/2019/03/12/517e01df-a412-4fb6-8386-9d91574035f6/","content":"### 1、概要\n作为团队开发的一项重要利器，使用好Git是一件重要的事情；提高协作效率，节约协作时间。\n<!-- more -->\n### 2、基础知识\n#### 2.1 环境的搭建\n#### 2.2 推送第一个文件至GitHub代码仓库\n#### 2.3 原理\n### 3、命令行维护\n#### 3.1 \n","tags":["Git"]},{"title":"Spring容器和Bean的关系、注解笔记","url":"/2019/03/12/b2ba0f8c-51ee-4f62-ab87-c572ca411bc7/","tags":["Spring"]},{"title":"开发规范笔记","url":"/2019/03/07/16d9fb52-dd5b-4339-9b38-a98df48a8b46/","content":"### 概要\n日常开发中，虽然代码可用性通过，要求的功能实现了，但是有一些规范需要去遵守；避免不注意犯了一些低级错误；本文笔记梳理一些常忽略的点，以免下次再进坑；\n<!--more-->\n1、公共类中的方法最好不要动；\n2、uuid要谨慎使用；\n3、公共的方法要放到公共的类中；\n4、业务类的方法比较多，取名字要规范一些，长点不要紧，但是一定要读出来方法的作用是什么；如果表达不出来，加上必要的注释；\n5、尽量不要捕获类似Exception通用异常，而是捕获特定的异常，具体到哪一种子类型；\n6、在复杂的生产系统中，标准出错STERR不是合适的输出选项，尤其是分布式系统，最好使用产品日志；详细的输出到日志系统中；STREE无法找到堆栈轨迹；\n不要在<b>catch</b>代码块中直接[printStackTrace()](https://docs.oracle.com/javase/9/docs/api/java/lang/Throwable.html#printStackTrace--)","tags":["总结"]},{"title":"前后端开发中对数据类型的理解和笔记","url":"/2019/03/07/f34c66e6-28df-4cc4-bac1-ac4e0cf6bb6a/","content":"### 1、概要\n总结一下基础知识，关于最近前后端的开发中，对基础知识点的理解和重新认识；主要包括Java的List/Map、以及JSON格式的数据与数组转换的总结；\n<!--more-->\n### 2、背景\n首先根据开发中的两个需求，描述记录；\n1、在EHR系统开发中，对员工的特种作业证书进行筛选统计，筛选规则：将同一证书类型、同一证书名字、同一登记时间的，取变动时间最新的一条数据展示；\n2、前台报表显示列项目，前端Vue使用ElementUI的穿梭器实现；用户可以[自定义显示]要显示的列项目；每个用户的设置不一样；\n### 3、EHR中的解决描述记录\n##### 3.1 思路和具体实现\n员工的特种证书表中，冗余的数据太多，维护的太乱，一个证书可能有多次变动时间；数据的来源是从SAP生产800数据库中拉取过来，最新的记录没有标记；为了取数准确，每为员工的数据分两步取数：\n1、先取出<b>不包括</b>在【同一证书名称、类型、登记时间】这个条件的数据。用<b>GROUP BY</b>分组语句查询出来；\n2、再取出范围在【同一证书名称、类型、登记时间】这个条件的数据；\n看下表结构（仅仅罗列了关键的字段）：\n\n| 字段名称 | 类型| 备注 |\n| ------ | ------ | ------ |\n| employee_special_uuid | varchar | uuid |\n| employee_id | varchar | 员工ID |\n| special_operations_type | varchar | 证书类型 |\n| special_operations_project | varchar | 证书项目（名字）|\n| special_operations_record_date | date | 登记日期 |\n| sp_begin_date | date | 变动日期 |\n| sp_end_date | date | 结束日期 |\n\n\n```shell\nSELECT\n\t t.employee_id  ,\n\t t.special_operations_type  ,\n\t t.special_operations_project  ,\n\t t.special_operations_cert_code  ,\n\t t.special_operations_cert_date  ,\n\t t.special_operations_cert_end_date  ,\n\t t.special_operations_expire_date  ,\n\t t.special_operations_part_time  ,\n\t t.special_operations_status  ,\n\t t.special_operations_record_date  ,\n\t t.employee_special_uuid  ,\n\t t.special_operations_status_text  ,\n\t t.special_operations_part_time_text  ,\n\t t.special_operations_cert_org  ,\n\t t.special_operations_type_text  ,\n\t t.special_operations_project_text  ,\n\t t.sp_remark  ,\n\t t.sp_begin_date  ,\n\t t.sp_end_date\nFROM\n\tm_special_operations t\nWHERE\n\t(t.special_operations_type IN(\n\t\t(\n\t\t\tSELECT\n\t\t\t\tt.special_operations_type\n\t\t\tFROM\n\t\t\t\tm_special_operations t\n\t\t\tWHERE\n\t\t\t\tt.employee_id = #{employeeId}\n\t\t\tAND t.special_operations_status = '01'\n\t\t\tGROUP BY\n\t\t\t\tt.special_operations_type\n\t\t\tHAVING\n\t\t\t\tcount(t.special_operations_type) = 1\n\t\t)\n\t)\nor t.special_operations_project IN(\n\t(\n\t\tSELECT\n\t\t\tt.special_operations_project\n\t\tFROM\n\t\t\tm_special_operations t\n\t\tWHERE\n\t\t\tt.employee_id = #{employeeId}\n\t\tAND t.special_operations_status = '01'\n\t\tGROUP BY\n\t\t\tt.special_operations_project\n\t\tHAVING\n\t\t\tcount(t.special_operations_project) = 1\n\t)\n)\n\nor t.special_operations_record_date IN(\n\t(\n\t\tSELECT\n\t\t\tt.special_operations_record_date\n\t\tFROM\n\t\t\tm_special_operations t\n\t\tWHERE\n\t\t\tt.employee_id = #{employeeId}\n\t\tAND t.special_operations_status = '01'\n\t\tGROUP BY\n\t\t\tt.special_operations_record_date\n\t\tHAVING\n\t\t\tcount(t.special_operations_record_date) = 1\n\t)\n)\n)\n\nAND t.employee_id = #{employeeId}\nAND t.special_operations_status = '01'\ngroup by \n\t t.employee_id  ,\n\t t.special_operations_type  ,\n\t t.special_operations_project  ,\n\t t.special_operations_cert_code  ,\n\t t.special_operations_cert_date  ,\n\t t.special_operations_cert_end_date  ,\n\t t.special_operations_expire_date  ,\n\t t.special_operations_part_time ,\n\t t.special_operations_status  ,\n\t t.special_operations_record_date  ,\n\t t.employee_special_uuid  ,\n\t t.special_operations_status_text  ,\n\t t.special_operations_part_time_text  ,\n\t t.special_operations_cert_org  ,\n\t t.special_operations_type_text  ,\n\t t.special_operations_project_text  ,\n\t t.sp_remark  ,\n\t t.sp_begin_date  ,\n\t t.sp_end_date\n\norder by t.sp_begin_date desc\n```\n\n上述语句能够将<b>不包括</b>在【同一证书名称、类型、登记时间】这个条件的数据。<b>GROUP BY</b>的用法不记录笔记；\n<b>取出范围在【同一证书名称、类型、登记时间】这个条件的数据</b>只要稍微改动一下查询条件即可，这样，先把要求的数据集先取出来，然后在通过Java代码去处理List即可；\n<b>最后一个order by t.sp_begin_date desc其实用处很大的，group by已经分组了，然后将最新的时间排在了结果集的最上面，对于后边的List处理起到了很方便的作用；</b>\n```shell\nSELECT\n\t t.employee_id  ,\n\t t.special_operations_type  ,\n\t t.special_operations_project  ,\n\t t.special_operations_cert_code  ,\n\t t.special_operations_cert_date  ,\n\t t.special_operations_cert_end_date  ,\n\t t.special_operations_expire_date  ,\n\t t.special_operations_part_time  ,\n\t t.special_operations_status  ,\n\t t.special_operations_record_date  ,\n\t t.employee_special_uuid  ,\n\t t.special_operations_status_text  ,\n\t t.special_operations_part_time_text  ,\n\t t.special_operations_cert_org  ,\n\t t.special_operations_type_text  ,\n\t t.special_operations_project_text  ,\n\t t.sp_remark  ,\n\t t.sp_begin_date  ,\n\t t.sp_end_date\nFROM\n\tm_special_operations t\nWHERE\n\t(t.special_operations_type IN(\n\t\t(\n\t\t\tSELECT\n\t\t\t\tt.special_operations_type\n\t\t\tFROM\n\t\t\t\tm_special_operations t\n\t\t\tWHERE\n\t\t\t\tt.employee_id = #{employeeId}\n\t\t\tAND t.special_operations_status = '01'\n\t\t\tGROUP BY\n\t\t\t\tt.special_operations_type\n\t\t\tHAVING\n\t\t\t\tcount(t.special_operations_type) > 1\n\t\t)\n\t)\nand t.special_operations_project IN(\n\t(\n\t\tSELECT\n\t\t\tt.special_operations_project\n\t\tFROM\n\t\t\tm_special_operations t\n\t\tWHERE\n\t\t\tt.employee_id = #{employeeId}\n\t\tAND t.special_operations_status = '01'\n\t\tGROUP BY\n\t\t\tt.special_operations_project\n\t\tHAVING\n\t\t\tcount(t.special_operations_project) > 1\n\t)\n)\n\nand t.special_operations_record_date IN(\n\t(\n\t\tSELECT\n\t\t\tt.special_operations_record_date\n\t\tFROM\n\t\t\tm_special_operations t\n\t\tWHERE\n\t\t\tt.employee_id = #{employeeId}\n\t\tAND t.special_operations_status = '01'\n\t\tGROUP BY\n\t\t\tt.special_operations_record_date\n\t\tHAVING\n\t\t\tcount(t.special_operations_record_date) > 1\n\t)\n)\n)\n\nAND t.employee_id = #{employeeId}\nAND t.special_operations_status = '01'\ngroup by \n\t t.employee_id  ,\n\t t.special_operations_type  ,\n\t t.special_operations_project  ,\n\t t.special_operations_cert_code  ,\n\t t.special_operations_cert_date  ,\n\t t.special_operations_cert_end_date  ,\n\t t.special_operations_expire_date  ,\n\t t.special_operations_part_time ,\n\t t.special_operations_status  ,\n\t t.special_operations_record_date  ,\n\t t.employee_special_uuid  ,\n\t t.special_operations_status_text  ,\n\t t.special_operations_part_time_text  ,\n\t t.special_operations_cert_org  ,\n\t t.special_operations_type_text  ,\n\t t.special_operations_project_text  ,\n\t t.sp_remark  ,\n\t t.sp_begin_date  ,\n\t t.sp_end_date\n\norder by t.sp_begin_date desc\n```\n##### 3.2 Java代码的实现；\n先放上代码：\n```java\n    /**\n     * 获取资质信息（1、职称信息 2、职业资格 3、特种证书）\n     * @param employeeId\n     * */\n    @GetMapping(value = \"/getPostionTitleData/{employeeId}\")\n    @ResponseBody\n    public ObjectRestResponse getPostionTitleData(@PathVariable String employeeId) throws Exception{\n        List<MPostionTitle> list1 = mPostionTitleBiz.selectPostionTitleByEmpId(employeeId);\n\n        // 职业资格重复的记录\n        List<MProQualifications> mProQualificationsList = mProQualificationsBiz.selectProQuaById(employeeId);\n        // 职业资格不重复的记录；\n        List<MProQualifications> notRepeatMpqList = mProQualificationsBiz.selectMProQuaNotRepeat(employeeId);\n\n        // 特种证书重复的记录\n        List<MSpecialOperations> mSpecialOperationsList = mSpecialOperationsBiz.selectSpecOperationById(employeeId);\n        // 特种证书不重复的记录\n        List<MSpecialOperations> notRepeatMsoList = mSpecialOperationsBiz.selectSpecOPerationNotRepeat(employeeId);\n\n        // 处理职业资格重复的记录；\n        for (int i = 0; i < mProQualificationsList.size() - 1; ++i) {\n            DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");\n            if (mProQualificationsList.get(i).getEmployeeProType().equals(mProQualificationsList.get(i + 1))\n                    && mProQualificationsList.get(i).getEmployeeProLevel().equals(mProQualificationsList.get(i + 1))\n                    && mProQualificationsList.get(i).getEmployeeProDate().equals(mProQualificationsList.get(i + 1))) {\n                if (mProQualificationsList.get(i).getEmployeeProDate().getTime() > mProQualificationsList.get(i + 1).getEmployeeProDate().getTime()) {\n                    mProQualificationsList.set((i + 1), mProQualificationsList.get(i));\n                }\n            }\n        }\n        // 去除重复的记录\n        for (int i = 0; i < mProQualificationsList.size() - 1; i++) {\n            for (int j = mProQualificationsList.size() - 1; j > i; j--) {\n                mProQualificationsList.remove(j);\n            }\n        }\n        mProQualificationsList.addAll(notRepeatMpqList);\n\n        // 处理特种证书重复的记录；\n        for (int i = 0; i < mSpecialOperationsList.size() - 1; ++i) {\n            DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");\n            if (mSpecialOperationsList.get(i).getSpecialOperationsType().equals(mSpecialOperationsList.get(i + 1).getSpecialOperationsType())\n                    && mSpecialOperationsList.get(i).getSpecialOperationsProject().equals(mSpecialOperationsList.get(i + 1).getSpecialOperationsProject())\n                    && mSpecialOperationsList.get(i).getSpecialOperationsRecordDate().equals(mSpecialOperationsList.get(i + 1).getSpecialOperationsRecordDate())) {\n                if (mSpecialOperationsList.get(i).getSpBeginDate().getTime() > mSpecialOperationsList.get(i + 1).getSpBeginDate().getTime()) {\n                    mSpecialOperationsList.set((i + 1), mSpecialOperationsList.get(i));\n                }\n            }\n        }\n        // 去除重复的msList\n        for (int i = 0; i < mSpecialOperationsList.size() - 1; i ++) {\n            for (int j = mSpecialOperationsList.size() - 1;j > i; j-- ) {\n                if (mSpecialOperationsList.get(i).equals(mSpecialOperationsList.get(j))) {\n                    mSpecialOperationsList.remove(j);\n                }\n            }\n        }\n        mSpecialOperationsList.addAll(notRepeatMsoList);\n\n        Map map = new HashMap();\n        map.put(\"titleData\", list1);\n        map.put(\"proQualificationsData\", mProQualificationsList);\n        map.put(\"specialWorkData\", mSpecialOperationsList);\n\n        return new ObjectRestResponse().data(map);\n    }\n```\n\n拿特种证书来说，用for()循环，将List循环，for()的作用是将List中的元素全部设置为同一个元素，if条件语句是限定第i个元素和i+1个元素，如果相同，则是一样的，将i+1个元素设置为跟i一样，刚才上面说了，<b>最后一个order by t.sp_begin_date desc其实用处很大的，group by已经分组了，然后将最新的时间排在了结果集的最上面，对于List处理起到了很方便的作用；</b>处理之后的list，数据永远是符合要求的那一条；\n\n第二个for()循环的作用是出去list的重复值，其实只留下一个即可；用for()一个一个的remove()处理掉；这样剩余的就符合条件了；\n### 4、前台报表列显示与隐藏实现\n##### 4.1 思路和具体实现\n前台之前是用mock模拟实现的，这是存储的方式：\n```javascript\n  saveColumnSetting: config => {\n    localStorage.setItem('columns', JSON.stringify(JSON.parse(config.body).columns))\n    console.log('这是mock5')\n  },\n```\n存储到了localStorage中，如果浏览器清除缓存了，或者用户使用了另一个浏览器登录或者其他的电脑的登录，这个配置就会失效；\n这是用户打开页面加载的代码：\n```javascript\n  created() {\n    const model = 'projectApply';\n    getColumnSetting(model).then(response => {\n      if (response && response.length) {\n        this.columns = response\n      }\n    })\n  }\n```\n获取也是从localStorage中获取：\n```javascript\ngetColumnSetting: () => ({ data: JSON.parse(localStorage.getItem('columns')) })\n```\n这是向后传递的时候，调用的函数：\n```javascript\n    changeColumnWidth(newWidth, oldWidth, column) {\n      this.columns.forEach(el => {\n        if (el.code === column.property) {\n          el.width = newWidth\n        }\n      })\n      saveColumnSetting({ module: this.module, columns: JSON.stringify(this.columns) })\n    },\n```\ndata的内容是：\n```javascript\n{ module: this.module, columns: JSON.stringify(this.columns) }\n```\n其中用到了<b>JSON.stringify()</b>函数，将数组转换成JSON的格式，存储到后端的columns字段中；\n这是接口，函数传递过来的是data：\n```javascript\nexport function saveColumnSetting(data) {\n  return request({\n    url: '/api/crm/mdColumnsShow/saveColumnSetting',\n    method: 'post',\n    data\n  })\n}\n```\n<b>this.columns</b>是一个数组，可以使用forEach箭头函数将其遍历；\n那就需要将这部分的配置，存储到数据库中，下面是存储的表结构：\n\n| 字段名称 | 类型| 备注 |\n| ------ | ------ | ------ |\n| id | varchar | uuid |\n| module | varchar | 模块名称 |\n| user_id | varchar | 用户Id|\n| user_name | varchar | 用户名字 |\n| columns | date | 列的配置 |\n\n\n### 总结\n总结上述的过程，操作List;","tags":["总结"]},{"title":"MySQL常见问题及优化","url":"/2019/01/26/mysql-comtimization/","content":"## MySQL的优化方案有哪一些？\n本文介绍一下优化SQL语句和优化索引。\n\n### 本文记录MySQL 本文梗概如下:\n* 优化SQL\n* 优化索引\n* 开启查询缓存\n<!-- more -->\n* 配合使用Redis\n* MySQL主从复制\n* 优化MySQL自带的分区表\n* 垂直拆分,分解大系统,成为小系统,分布式系统\n* 水平拆分\n* 硬件上的升级、存储引擎、MySQL本身的配置文件\n\n## （一）优化SQL\n#### 1、通过MySQL自有的优化语句\n优化SQL语句，通过脚本命令来了解执行率较低的语句，显示一下状态等。\n* SHOW命令\n  * SHOW Status可以了解SQL的执行频率。可以显示日志，显示特定的数据库、表、索引以及进程还有权限表中的信息等等。\n介绍一些常见的字段\n  * Innodb_rows_read:Select查询返回的行数。\n  * Innodb_rows_inserted:执行INSERT操作插入的行数。\n  * Innodb_rows_updated:执行UPDATE操作更新的行数。\n  * Innodb_rows_deleted:执行DELETE操作删除的行数。\n\n","tags":["MySQL"]},{"title":"MyBatis语法总结","url":"/2019/01/02/mybatis-exc/","content":"## 背景\n* MyBatis在一些情况下，与在MySQL里面直接查询两者的运行情况（此处无关结果集）不一定是一样的，有些语句在MyBatis中运行是报错的。\n<!-- more -->\n\n## MyBatis中的<where></where>标签\n\n","tags":["MyBatis"]},{"title":"Vue.js生命周期理解","url":"/2019/01/02/vue-life-cycle/","tags":["Vue.js"]},{"title":"前端后端数据交互过程例解与调试","url":"/2018/12/29/debugger-skills/","content":"## 背景\n前后端分离项目进行数据交互的时候，出现错误改如何快速定位调试。\n<!-- more -->\n## 前后交互数据的过程\n","tags":["技术"]},{"title":"方案解决与思路提示","url":"/2018/12/25/issues-reminders/","content":"\n## 背景\n旨在积累一些问题的解决方案和思路，下次出现快速解决。少走弯路；提高效率。\n<!-- more -->\n### 微服务分机部署\n* 分机部署，如果是不同服务商的服务器，加载速度会变得很慢。可以使用CDN加速。即使是同一个运营商不同地域的，也会这样。\n* 记得开放端口和设置安全组规则（比如阿里云的），想当于设置白名单。\n* 微服务的占用性能比较大，如果在出现线程被自动kill的现象，要即使查看是不是内存不足导致，从而出发了kill最大内存的进程。\n\n### 整理自己的资料\n* 学会使用标签。\n* Notes是个好东西。\n* 之后每份重要的文件都要放上标签，便于查找。\n* 自己的资料库要形成索引。","tags":["技术"]},{"title":"后端开发开发遇到的问题和总结","url":"/2018/12/19/server-spring-cloud-qa-and-summary/","content":"\n## 背景\n微服务开发中基础知识整理和技巧整理。\n<!-- more -->\n\n## 生日跨年查询\n代码：\n```java\n    <select id=\"selectByBirthday\" parameterType=\"com.security.common.entity.PageExample\" resultMap=\"BaseResultMap\">\n        select a.* from (\n        SELECT\n        t.*, y.position_name\n        FROM\n        m_employee_info t\n        LEFT JOIN m_position y ON t.position_id = y.position_id\n        WHERE\n        t.employee_id IS NOT NULL\n        <if test=\"data.startDataBirthdayPoint != null and data.startDataBirthdayPoint != '' and data.endDataBirthdayPoint != null and data.endDataBirthdayPoint !=''\">\n            AND DATE_FORMAT(t.employee_birthday , '%m%d') BETWEEN #{data.startDataBirthdayPoint} AND #{data.endDataBirthdayPoint}\n        </if>\n        UNION ALL\n        SELECT\n        t.*, y.position_name\n        FROM\n        m_employee_info t\n        LEFT JOIN m_position y ON t.position_id = y.position_id\n        WHERE\n        t.employee_id IS NOT NULL\n        <if test=\"data.startDataBirthdayPoint != null and data.startDataBirthdayPoint != '' and data.endDataBirthdayPoint != null and data.endDataBirthdayPoint !=''\">\n            AND DATE_FORMAT(t.employee_birthday , '%m%d') BETWEEN #{data.startDataBirthdayPoint} AND '1231'\n        </if>\n        UNION ALL\n        SELECT\n        t.*, y.position_name\n        FROM\n        m_employee_info t\n        LEFT JOIN m_position y ON t.position_id = y.position_id\n        WHERE\n        t.employee_id IS NOT NULL\n        <if test=\"data.startDataBirthdayPoint != null and data.startDataBirthdayPoint != '' and data.endDataBirthdayPoint != null and data.endDataBirthdayPoint !=''\">\n            AND DATE_FORMAT(t.employee_birthday , '%m%d') BETWEEN '0101' AND #{data.endDataBirthdayPoint}\n        </if>\n        ) as a\n    </select>\n```\n* 查询生日，将年份截取，只传入月和日。\n* 在跨年处理的时候，需要将时间截断一下。开始的时间到1231，作为一个阶段，从0101到终止的时间，作为第二个阶段。\n\n#### 有第二种方法但是不推荐这样写\n\n```java\nSELECT\n    *\nFROM\n    m_employee_info t\nWHERE(date_add(t.employee_birthday ,INTERVAL TIMESTAMPDIFF(YEAR ,t.employee_birthday ,DATE_FORMAT(now() , '%Y-%m-%d')) YEAR))\n    BETWEEN '2018-12-01' AND '2019-01-15'\nOR(date_add(t.employee_birthday ,INTERVAL TIMESTAMPDIFF(YEAR ,t.employee_birthday ,DATE_FORMAT(now() , '%Y-%m-%d'))+1 YEAR))\n    BETWEEN '2018-12-01' AND '2019-01-15'\n```\n\n* ```上述代码使用Navicat的Beautify SQL功能美化整理```\n* 也能实现跨年查询，还需要另外加一部分\n* 这样的问题是函数比较多，每次将所有的用户的生日全部改成查询起始时间点的所在年份，如果人多，性能会比较低。\n\n## MyBatis映射文件中的注意事项\n* ResultMap中子标签```<result/>```标签中的```property```和```column```对应字段必须所在的```entity```实体类中；\n* 如果```entity```实体类中存在，但是没有写在```ResultMap```中，则不显示；\n* ```<if>```标签中存在```if```条件，如果外层关联过许多表的话，查询出的数据结果集可能会用重复，因此，限制条件必须要放到外层，而不是写在```<if>```标签中；\n* 在```Navicate```中的```union all```语句是能够正确查询的，但是放到```mapper```映射文件中，需要加一层，```select a.* from (...) a```；\n* MyBatis中不支持通常写法的大于号和小于号，这里需要转义：大于号：```&gt;```，小于号：```&lt;```；\n","tags":["Spring Cloud"]},{"title":"前端开发Vue.js问题整理与总结","url":"/2018/12/18/front-vue-js-qa-and-summary/","content":"## 背景\n* 所在的项目上前端开发使用技术栈为Vue.js。\n* 本文的主要内容开发时候遇到的问题、解决的方案、常用的解决方法。\n* 思路。\n<!-- more -->\n## 测试代码高亮\n\n```javascript\n// 简单语法\nVue.component('props-demo-simple', {\n  props: ['size', 'myMessage']\n})\n\n// 对象语法，提供校验\nVue.component('props-demo-advanced', {\n  props: {\n    // 检测类型\n    height: Number,\n    // 检测类型 + 其他验证\n    age: {\n      type: Number,\n      default: 0,\n      required: true,\n      validator: function (value) {\n        return value >= 0\n      }\n    }\n  }\n})\n```\n## 组件弹窗\n* 原因:主要原因是没理解弹窗的原理。写的时候没有按照步骤和关键点进行。\n\n## JavaScript数据结构\n* 对JavaScript数组的理解不熟悉。\n* 对返回的数据做不出明确的判断来。\n\n## 组件通信\n\n## 数据绑定\n\n\n","tags":["Vue.js"]},{"title":"微服务模块的理解","url":"/2018/12/17/micro-service/","content":"## 项目微服务结构整体理解\n## 背景\n* 各司其职、集中管理、存在单向或多向调用关系；\n<!-- more -->\n\n## 意义\n* 提高迭代效率；\n* 降低开发黏连性；\n* 节约成本\n\n## 实现\n### 结构\n#### 项目启动的入口CenterBootstrap\n* 各项服务的注册、管理中心。\n* 微服务请求转发。\n#### 鉴权（权限）服务AuthBootstrap\n* JWT处理权限\n#### 字典服务DictBootstrap\n* 管理项目的数据字典。\n#### 后台管理服务AdminBootstrap\n* 连接数据库、处理数据。\n#### 网关服务GateBootstrap\n* 接收前端的请求并转发至其他服务。","tags":["微服务"]},{"title":"iOS开发基础之学习Objective-C笔记一","url":"/2018/12/11/ios-init-oc-lang/","content":"## 前言\n<!-- more -->\n\n## 背景\n* 学习一门新的手艺。\n* 做个小的Demo，解决自己对于现有的某些工具不能满足自己需求的痛点。\n* Apple Store一些应用需要花钱。\n\n## 计划\n* 第一、先看书。重点关注一下指针这块。\n* 第二、照着实例写一写UI。画一画界面。\n* 第三、写一写后台的逻辑。实现一些小的功能。\n* 第四、整合记录一下笔记和发布一下源码。提升一下。\n* 第五、规划一个tools的功能，写计划书，准备开发。","tags":["Objective-C"]}]