[{"title":"Java List深拷贝","url":"/2020/03/16/d2fcc40a-e791-4704-8ddb-d0123aed0904/","content":"<!-- more -->\n\n## 1 概要\n遇到一个取数的过程业务代码段：<br>\n```java\n    // ......\n    List<T> list1 = xx.getListByParam(param1);\n    map.put(\"list1\",list1);\n    List<T> list2 = xx.getListByParam(param2);\n    map.put(\"list2\", list2);\n    // ......\n```\n其中，list1中，某属性的值，在list2获取的过程中，发生改变。出现问题。\n\n\n## 2 Java List 深拷贝的问题\n\n解决方法\n```java\n    public static <T> List<T> deepCopy(List<T> list) throws IOException, ClassNotFoundException {\n\n        ByteArrayOutputStream arrayOutputStream = new ByteArrayOutputStream();\n        ObjectOutputStream objectOutputStream = new ObjectOutputStream(arrayOutputStream);\n        objectOutputStream.writeObject(list);\n\n        ByteArrayInputStream arrayInputStream = new ByteArrayInputStream(arrayOutputStream.toByteArray());\n        ObjectInputStream objectInputStream = new ObjectInputStream(arrayInputStream);\n\n        @SuppressWarnings(\"unchecked\")\n        List<T> reList = (List<T>) objectInputStream.readObject();\n        return reList;\n    }\n```\n\n## 3 问题分析\n代码表现是：\n* Controller类中的两个不同的方法，调用了同一个Serveice类中的方法\n* 这个动作是一个查询动作引起\n* 这个动作到了Controller层，会调用多次、多个Service类的方法\n\n避免出现此问题，导致数据不准确，则需要考虑Java List的深拷贝的问题。\n\n## 4 分析List的深浅拷贝","tags":["java"]},{"title":"Redis关于内存和内存优化笔记","url":"/2020/03/06/ad5161c0-03f5-4340-9b8e-cc8566503dea/","content":"<!--more-->\n# 1、概要\n系统学习Redis的内存和内存优化主题笔记。\n参考资料：https://github.com/Weiwf/redis-mindmap 的思维导图。\n"},{"title":"Java之JVM的总结与对垃圾回收的实践","url":"/2020/03/06/e648e796-99ff-4832-9063-21981d0b67d4/","content":"<!-- more -->\n## 1、概要\n### 1.1、背景\n出于对Java代码优化的理解和对JVM的深一步理解，借助部分资源，学习、总结；\n参考资料是(https://github.com/Weiwf/JVM-mindmap.git)[https://github.com/Weiwf/JVM-mindmap.git]里面的思维导图。\n还有《深入理解Java虚拟机》书籍。\n### 1.2、实现目标\n* 总结JVM知识提纲\n* 开发事习惯打开GC日志，习惯分析\n* 优化参数多，能够借助第三方工具，进行GC日志分析，通过日志分析，对代码进行改造\n* 学习与改造第三方工具，加深理解\n\n## 2、JVM的内存结构\n","tags":["jvm"]},{"title":"记录软件开发的诞生---套用软件工程学，进行开发。","url":"/2020/03/06/2566b127-2c3e-4539-ab75-51dc0a72db16/","content":"<!--more-->\n# 1、概要\n想到啥，写啥。\n打算从设计、到代码。\n\n* iOS使用Objective-C + Swift\n* Android使用Java\n* 后端使用Java Spring Boot\n* PC使用Vue.js\n\n### 1.1、要做啥呢？\ncommunity? or shop?\n"},{"title":"使用Bash Shell实现自定义信息修改flowable工作流引擎war包配置","url":"/2020/02/17/2eeba61b-ff4b-4166-ae26-ee61b6002724/","content":"<!-- more -->\n\n**变更记录**\n\n| 变更项 | 时间 | 更新者 |\n| --- | --- | --- |\n| 初始化文档，实现war包的处理| 2020.01 | me |\n\n# 1、概要\n部署flowable工作流引擎，需要根据所在服务器的IP和MySQL账密信息，修改很多配置项，为方便，这些配置项，采用脚本批处理的方式，将用户在终端输入的信息，进行处理并修改配置项。\n\n\n# 2、脚本内容\n脚本做了以下事情：\n* 解压flowable.zip\n* 创建flowable-admin等5个文件夹，并将flowable-admin.war等5个war包依次移动至相对应的文件夹\n* 解压war包 && 进入指定目录，处理配置文件\n* 接受用户输入的配置项各项信息\n* 每一个配置文件输入结束时，会确认是否要继续，正确输入y，则生成application.properies配置文件\n* 错误则输入n，输入指定的数字，进行纠正，直至用户输入y确认成配置文件\n* 将处理好的文件，打包成war包\n\n\n# 3、实现\n如图，使用的时候，保证脚本和压缩包在同一目录下：\n![](https://flowable-deploy.oss-cn-beijing.aliyuncs.com/tutorial/Screen%20Shot%202020-03-21%20at%2022.55.40.png)\n<br>\n这段代码是获取路径\n\n```shell\nCURDIR=$(\n\tcd $(dirname ${BASH_SOURCE[0]})\n\tpwd\n)\n```\n<br>\n处理用户输入内容\n```shell\ncd flowable-admin/WEB-INF/classes\nrm -rf application.properties\ntouch application.properties\n# 提示端口，如果不输入，会有默认值9988\necho -n \"[1]please input the server.port = ? (default is 9988)\"\nread port\nif [[ $port == \"\" ]]; then\n\tport='9988'\nfi\n\necho -n \"your server.port is $port\"\n\necho -n \"[13]please input the MySQL server host ip = ? (default is 127.0.0.1)\"\nread MySQLHostIp\nif [[ $MySQLHostIp == \"\" ]]; then\n\tMySQLHostIp='127.0.0.1'\nfi\n\necho -n \"[14]please input the MySQL server host port = ? (default is 3306)\"\nread MySQLHostPort\nif [[ $MySQLHostPort == \"\" ]]; then\n\tMySQLHostPort='3306'\nfi\n```\n<br>\n上文说过，如果错了，是可以根据序号修正输入信息的。如果flag不为y，则会一直询问正确输入，直至输入y为止。\n```shell\nread flag\nwhile [[ $flag == \"n\" ]]; do\n\techo 'input number 1 to 26, the numbers are not continuous'\n\techo 'your number is'\n\tread aNum\n\tcase $aNum in\n\t1)\n\t\techo 'number is 1, please fix your [port] current!'\n\t\tread line1\n\t\tport=$line1\n\t\t;;\n\t13)\n\t\techo 'number is 13, please fix your [the MySQL server host ip] current!'\n\t\tread line13\n\t\tMySQLHostIp=$line13\n\t\t;;\n\t14)\n\t\techo 'number is 14, please fix your [the MySQL server host port] current!'\n\t\tread line14\n\t\tMySQLHostPort=$line14\n\t\t;;\n\t*)\n\t\techo 'Error'\n\t\t;;\n\tesac\n\techo -n \"confirm，if wrong, please choice 'n' to fix it !, input y/n:\"\n\tread flag\ndone\n```\n\n<br>\n最后，使用\n\n```shell\ncat >application.properties <<EOF\n```\n\n并配合类似:\n\n```shell\nspring.datasource.username=$datasourceUsername\nspring.datasource.password=$datasourcePassword\n```\n\n将读取终端input的变量值写入要生成的配置文件中。\n\n# 4、脚本地址\nhttps://flowable.oss-cn-beijing.aliyuncs.com/semi_auto_deploy_flowable_sample.sh","tags":["shell"]},{"title":"Element UI之Cascader 级联选择器多选操作","url":"/2019/12/24/48acf05e-5b94-4e18-b62a-f277e34237fb/","content":"<!-- more -->\n## 1、概要\n### 1.1、级联选择器，树型展示\nElement UI的官网链接：[https://element.eleme.cn/#/zh-CN/component/cascader](https://element.eleme.cn/#/zh-CN/component/cascader)\n使用环境：\n`\"element-ui\": \"2.9.0\",`\n需要依赖为2.9.x及以上，配合 \n`\"vue\": \"2.5.22\"` 以上。\n如果版本不匹配，多选操作是显示不出来的。\n### 1.2、需求描述\n数据库中存在两张表，user表和org表，user表中有字段org_id，记录这个人所属的组织id，org表中有org_id，org_name等字段。\n表结构简介如下\nuser:\n\n| id | name | org_id | ... | \n| --- | --- | --- |--- |\n| 1 | admin | 10000000|...|\n\norg\n\n| org_id | org_name | parent_org_id |\n| --- | --- | --- |\n| 00000000 | 刑部 | -1 |\n| 10000000 | 六扇门 | 00000000 |\n| 10000001 | 总管 | 10000000 |\n| 10000002 | 办公室 | 10000000 |\n| 10000003 | 兵器管理 | 10000000 |\n| 10000003 | 财政 | 10000000 |\n| 10000003 | 保洁 | 10000000 |\n\n* 目前每个人只有一个所属组织\n* 管理员，部门负责人在进行组织查询的时候，只能有本部门及其子部门的展示权限\n* 虽然不属于部门B，但是想看到部门B的信息，单选满足不了，靠两个表维护不了多选的信息。\n\n基于以上来自产品顾问天马星空的想法，对现有的情况进行改造。\n","tags":["elementui"]},{"title":"开发规范笔记与经验","url":"/2019/03/07/16d9fb52-dd5b-4339-9b38-a98df48a8b46/","content":"<!--more-->\n# 1、概要\n日常开发中，虽然代码可用性通过，要求的功能实现了，但是有一些规范需要去遵守；避免不注意犯了一些低级错误；本文笔记梳理一些常忽略的点，以免下次再进坑；\n\n1、公共类中的方法最好不要动；\n2、uuid要谨慎使用；\n3、公共的方法要放到公共的类中；\n4、业务类的方法比较多，取名字要规范一些，长点不要紧，但是一定要读出来方法的作用是什么；如果表达不出来，加上必要的注释；\n5、尽量不要捕获类似Exception通用异常，而是捕获特定的异常，具体到哪一种子类型；\n6、在复杂的生产系统中，标准出错STERR不是合适的输出选项，尤其是分布式系统，最好使用产品日志；详细的输出到日志系统中；STREE无法找到堆栈轨迹；\n不要在<b>catch</b>代码块中直接[printStackTrace()](https://docs.oracle.com/javase/9/docs/api/java/lang/Throwable.html#printStackTrace--)\n7、[配置文件]在微服务的resources下的配置文件，可能会有许多的配置文件，每个配置文件尽量要求做到名字直观易懂，必要时在配置文件中做出单独的说明；\n8、Java的类名开头要写明是什么；\n9、Java中的方法要写明作者、邮箱、版本、参数、返回；\n\n# 2、关于异常\n### 2.1、图片的异常\n如果图片不存在，就会在程序运行时引起异常，图片如果是网络资源，有一种方法，如下，可以处理图片异常的情况。\n获取图片的url，记得关闭流。对于异常的情况，则给一个固定的、一定存在的连接。\n```java\n        try {\n            URL urlTemp = new URL(url + employeeInfo.getEmployeeId() + \".jpg\");\n            URLConnection uc = urlTemp.openConnection();\n            InputStream in = uc.getInputStream();\n            in.close();\n        } catch (Exception e) {\n\n            map.put(\"photoUrl\",\"http://192.168.6.125/static/photo/default/boy.png\");\n            e.printStackTrace();\n        }\n```\n","tags":["总结"]},{"title":"EHR系统员工生日提醒（跨年查询）总结与笔记","url":"/2018/12/19/81e30f7a-a061-4cfb-aace-39fdf4860955/","content":"<!-- more -->\n### 1、概要\n生日跨年提醒，在EHR系统中，用户选择某个时间段都那些人过生日，并发送邮件提醒；本文只描述如何去跨年查询。\n前端使用Vue.js/Element UI;\n后端使用Java/Spring Cloud/微服务架构模式\n本文修改于：2019年03月15日\n\n### 2、思路\n1、前端获取的是时间段，用户输入的时间段发送给后端的时候，判断一下用户选择的时间；\n2、如果没有跨年，则调用函数a；\n3、如果跨年了，则调用函数b；\n### 3、实现过程\n#### 3.1、前端实现\n###### 3.1.1、界面效果\n\n![](../../../../../../images/2.png)\n\nElement UI时间组件：[点击这里](http://element-cn.eleme.io/#/zh-CN/component/date-picker)\n\n###### 3.1.2、前端代码\n```javascript\n      handleFilter() {\n        this.searchkpi();\n        this.listQuery.startDataBirthdayPoint = this.employeeBirthday[0].toString().substring(5, 10).replace('-', '')\n        this.listQuery.endDataBirthdayPoint = this.employeeBirthday[1].toString().substring(5, 10).replace('-', '')\n        if (this.employeeBirthday[0].toString().substring(0, 4) === this.employeeBirthday[1].toString().substring(0, 4)) {\n          this.getListNotAcrossYear();\n        } else {\n          this.getList();\n        }\n      }\n      // 代码片段1\n```\n第5行代码，判断了年份是否相同，如果年份是否相同，如果相同，则调用<b>this.getListNotAcrossYear</b>, 调用接口：<b>pageBirthdayNotAcrossYear()</b>, 参数为this.listQuery;\n```javascript\n      getListNotAcrossYear() {\n        this.loading = true;\n        pageBirthdayNotAcrossYear(this.listQuery)\n          .then(response => {\n            this.list = response.data.rows;\n            this.total = response.data.total;\n            this.loading = false;\n          }).catch(error => {\n            console.error(error)\n            this.loading = false\n          })\n      }\n       // 代码片段2\n```\n<b>this.listQuery</b>包含两个字段：\n```javascript\n          startDataBirthdayPoint: undefined,\n          endDataBirthdayPoint: undefined\n           // 代码片段3\n```\n这两个字段，作为listQuery的一部分，作为参数，通过前端的API请求接口，传递给后端:\n```javascript\n// 生日提醒\nexport function pageBirthdayNotAcrossYear(query) {\n  return request({\n    url: '/api/admin/mEmployeeInfo/pageBirthdayNotAcrossYear',\n    method: 'get',\n    params: query\n  })\n}\n // 代码片段4\n```\n从接口中可以看到：传入的参数是<b>query</b>,使用GET的方式传递给后端。\n相同的，在<b>代码片段1</b>中的第8行，则是请求跨年的，在前端的代码部分都是一样的，这里我是在前端就对其进行了分开，后来想了想，如果日期传递到后端，在后端进行处理，代码量要少很多。\n#### 3.2、后端实现\n先看下不跨年的，包含Java代码和MyBatis的.xml映射文件；\n###### 3.2.1、Java代码\n首先是Controller类：\n```java\n@RequestMapping(\"mEmployeeInfo\")\n// 代码片段5\n```\n应和了在代码片段4中的请求接口；\n这是Java代码Controller的函数：\n```java\n    @RequestMapping(value = \"/pageBirthdayNotAcrossYear\", method = RequestMethod.GET)\n    @ResponseBody\n    public TableResultResponse<MEmployeeInfo> selectBirthdayNotAcrossYear(@RequestParam Map<String, Object> params) {\n        PageQuery query = new PageQuery(params, params);\n        return mEmployeeInfoBiz.selectBirthdayNotAcrossYear(query);\n    }\n    //代码片段6\n```\n\n函数的类型是<b>TableResultResponse</b>,返回的是一个结果集；\n\n这是Java代码Service类的函数：\n```java\n    // 生日到期提醒(不跨年)\n    public TableResultResponse<MEmployeeInfo> selectBirthdayNotAcrossYear(PageQuery<MEmployeeInfo> query) {\n        PageExample example = new PageExample(MEmployeeInfo.class, query.getData());\n        Page<MEmployeeInfo> result = PageHelper.startPage(query.getPage(), query.getLimit());\n        List<MEmployeeInfo> list = mEmployeeInfoMapper.selectBirthdayNotAcrossYear(example);\n        if (list.size() > 0){\n            try {\n                mergeCore.mergeResult(MEmployeeInfo.class, list);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return  new TableResultResponse<MEmployeeInfo>(result.getTotal(), list);\n    }\n    // 代码片段7\n```\nDAO类\n```java\nList<MEmployeeInfo> selectBirthdayNotAcrossYear(Object example);\n// 代码片段8\n```\n#### 3.2.2、MyBatis的映射文件\n接下来是MyBatis的映射文件代码\n```java\n    <select id=\"selectBirthdayNotAcrossYear\" parameterType=\"com.savor.security.common.entity.PageExample\" resultMap=\"BaseResultMap\">\n        SELECT\n        t.*, y.position_name\n        FROM\n        m_employee_info t\n        LEFT JOIN m_position y ON t.position_id = y.position_id\n        WHERE\n        t.employee_id IS NOT NULL\n        <if test=\"data.startDataBirthdayPoint != null and data.startDataBirthdayPoint != '' and data.endDataBirthdayPoint != null and data.endDataBirthdayPoint !=''\">\n            AND DATE_FORMAT(t.employee_birthday , '%m%d') BETWEEN #{data.startDataBirthdayPoint} AND #{data.endDataBirthdayPoint}\n        </if>\n    </select>\n    -- 代码片段9\n```\n\n跨年的请求处理，跟上面的代码没有区别，不同之处体现在最后的映射文件这里：\n```java\n    <select id=\"selectByBirthday\" parameterType=\"com.savor.security.common.entity.PageExample\" resultMap=\"BaseResultMap\">\n        select a.* from (\n        SELECT\n        t.*, y.position_name\n        FROM\n        m_employee_info t\n        LEFT JOIN m_position y ON t.position_id = y.position_id\n        WHERE\n        t.employee_id IS NOT NULL\n        <if test=\"data.startDataBirthdayPoint != null and data.startDataBirthdayPoint != '' and data.endDataBirthdayPoint != null and data.endDataBirthdayPoint !=''\">\n            AND DATE_FORMAT(t.employee_birthday , '%m%d') BETWEEN #{data.startDataBirthdayPoint} AND #{data.endDataBirthdayPoint}\n        </if>\n        UNION ALL\n        SELECT\n        t.*, y.position_name\n        FROM\n        m_employee_info t\n        LEFT JOIN m_position y ON t.position_id = y.position_id\n        WHERE\n        t.employee_id IS NOT NULL\n        <if test=\"data.startDataBirthdayPoint != null and data.startDataBirthdayPoint != '' and data.endDataBirthdayPoint != null and data.endDataBirthdayPoint !=''\">\n            AND DATE_FORMAT(t.employee_birthday , '%m%d') BETWEEN #{data.startDataBirthdayPoint} AND '1231'\n        </if>\n        UNION ALL\n        SELECT\n        t.*, y.position_name\n        FROM\n        m_employee_info t\n        LEFT JOIN m_position y ON t.position_id = y.position_id\n        WHERE\n        t.employee_id IS NOT NULL\n        <if test=\"data.startDataBirthdayPoint != null and data.startDataBirthdayPoint != '' and data.endDataBirthdayPoint != null and data.endDataBirthdayPoint !=''\">\n            AND DATE_FORMAT(t.employee_birthday , '%m%d') BETWEEN '0101' AND #{data.endDataBirthdayPoint}\n        </if>\n        ) as a\n    </select>\n```\n其中也分成了三段，第一段就是正常的输入日期，但是不会去调用了。\n后两段是：\n如果跨年的时候，比如选择这个时间段2018-12-05~2019-03-15进行查询，那么数据流到映射文件这里的时候，会被分成两段（因为生日是考虑月日的，不考虑年）：就是12-05~12-31一部分人；01-01~03-15第二部分人；最后加起来，就是要的人数；\n\n","tags":["Spring Cloud"]}]